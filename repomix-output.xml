This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
backup.js
db.js
groups.js
index.js
marks.js
meets.js
members.js
settings.js
stats.js
tasks.js
types.js
workspace.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="backup.js">
import { getDb } from './db';
import * as settings from './settings';
import * as meets from './meets';
import * as groups from './groups';
import * as tasks from './tasks';
import * as marks from './marks';
import * as members from './members';

export async function clearReports() {
    const db = await getDb();
    await db.clear('meets');
}

export async function clearGroups() {
    const db = await getDb();
    await db.clear('groups');
}

export async function clearMarks() {
    const db = await getDb();
    await db.clear('tasks');
    await db.clear('marks');
}

export async function clearMembers() {
    const db = await getDb();
    await db.clear('members');
}

export async function clearAll() {
    await clearReports();
    await clearGroups();
    await clearMarks();
    await clearMembers();
    settings.clearSettings();
}

// Full backup format:
// version 3:
// - meets, groups, tasks, marks, members
// - settings: { ignoredUsers, durationLimit, defaultTeacher }
export async function exportData() {
    const [allMeets, allGroups, ignoredUsers, durationLimit, defaultTeacher, allTasks, allMarks, allMembers] = await Promise.all([
        meets.getAllMeets(),
        groups.getGroups(),
        settings.getIgnoredUsers(),
        settings.getDurationLimit(),
        settings.getDefaultTeacher(),
        tasks.getAllTasks(),
        marks.getAllMarks(),
        members.getAllMembers()
    ]);

    return {
        meets: allMeets,
        groups: allGroups,
        tasks: allTasks,
        marks: allMarks,
        members: allMembers,
        settings: {
            ignoredUsers,
            durationLimit,
            defaultTeacher
        },
        version: 3, // Bump version
        timestamp: new Date().toISOString()
    };
}

export async function importData(jsonData) {
    if (!jsonData || !jsonData.meets || !jsonData.groups) {
        throw new Error('Invalid data format');
    }

    await clearAll();

    const db = await getDb();

    // Restore meets
    if (jsonData.meets.length > 0) {
        const txMeets = db.transaction('meets', 'readwrite');
        const storeMeets = txMeets.objectStore('meets');
        for (const meet of jsonData.meets) {
            await storeMeets.put(meet);
        }
        await txMeets.done;
    }

    // Restore groups
    if (jsonData.groups.length > 0) {
        const txGroups = db.transaction('groups', 'readwrite');
        const storeGroups = txGroups.objectStore('groups');
        for (const group of jsonData.groups) {
            await storeGroups.put(group);
        }
        await txGroups.done;
    }

    // Restore settings
    if (jsonData.settings) {
        const { durationLimit, defaultTeacher, ignoredUsers } = jsonData.settings;
        if (durationLimit !== undefined) {
            await settings.saveDurationLimit(durationLimit);
        }
        if (defaultTeacher) {
            await settings.saveDefaultTeacher(defaultTeacher);
        }
        // ignoredUsers is part of the full backup; restore it as well
        if (Object.prototype.hasOwnProperty.call(jsonData.settings, 'ignoredUsers')) {
            await settings.saveIgnoredUsers(Array.isArray(ignoredUsers) ? ignoredUsers : []);
        }
    }

    // Restore tasks with upsert logic (preserve IDs for existing tasks)
    const taskIdMapping = new Map(); // Maps old task IDs to new task IDs

    if (jsonData.tasks && jsonData.tasks.length > 0) {
        const tx = db.transaction('tasks', 'readwrite');
        const store = tx.objectStore('tasks');

        for (const task of jsonData.tasks) {
            const oldId = task.id;

            // Find existing task by natural key (name + date + groupName)
            const existing = await tasks.findTaskByNaturalKey(task.name, task.date, task.groupName);

            if (existing) {
                // Task exists - preserve its ID and update other fields
                await store.put({ ...task, id: existing.id });
                taskIdMapping.set(oldId, existing.id);
            } else {
                // New task - remove ID to let auto-increment assign one
                const { id, ...taskWithoutId } = task;
                const newId = await store.add(taskWithoutId);
                taskIdMapping.set(oldId, newId);
            }
        }
        await tx.done;
    }

    // Restore members
    if (jsonData.members && jsonData.members.length > 0) {
        const tx = db.transaction('members', 'readwrite');
        const store = tx.objectStore('members');
        for (const member of jsonData.members) {
            await store.put(member);
        }
        await tx.done;
    }

    // Restore marks with updated task IDs
    if (jsonData.marks && jsonData.marks.length > 0) {
        const tx = db.transaction('marks', 'readwrite');
        const store = tx.objectStore('marks');
        for (const mark of jsonData.marks) {
            // Update taskId to the new ID if mapping exists
            const newTaskId = taskIdMapping.get(mark.taskId) || mark.taskId;
            await store.put({ ...mark, taskId: newTaskId });
        }
        await tx.done;
    }
}

// Granular Export Methods
export async function exportReports() {
    const allMeets = await meets.getAllMeets();
    return {
        meets: allMeets,
        version: 1,
        type: 'reports',
        timestamp: new Date().toISOString()
    };
}

export async function exportGroups() {
    const allGroups = await groups.getGroups();
    return {
        groups: allGroups,
        version: 1,
        type: 'groups',
        timestamp: new Date().toISOString()
    };
}

// Marks backup format (version 2):
// {
//   type: 'marks',
//   version: 2,
//   tasks: Task[],
//   marks: Mark[],
//   members: Member[]
// }
export async function exportMarks() {
    const [allTasks, allMarks, allMembers] = await Promise.all([
        tasks.getAllTasks(),
        marks.getAllMarks(),
        members.getAllMembers()
    ]);
    return {
        tasks: allTasks,
        marks: allMarks,
        members: allMembers,
        version: 2,
        type: 'marks',
        timestamp: new Date().toISOString()
    };
}

// Granular Import Methods
export async function importReports(jsonData) {
    if (!jsonData || !jsonData.meets) {
        throw new Error('Invalid reports data format');
    }

    await clearReports();
    const db = await getDb();

    if (jsonData.meets.length > 0) {
        const tx = db.transaction('meets', 'readwrite');
        const store = tx.objectStore('meets');
        for (const meet of jsonData.meets) {
            await store.put(meet);
        }
        await tx.done;
    }
}

export async function importGroups(jsonData) {
    if (!jsonData || !jsonData.groups) {
        throw new Error('Invalid groups data format');
    }

    await clearGroups();
    const db = await getDb();

    if (jsonData.groups.length > 0) {
        const tx = db.transaction('groups', 'readwrite');
        const store = tx.objectStore('groups');
        for (const group of jsonData.groups) {
            await store.put(group);
        }
        await tx.done;
    }
}

export async function importMarks(jsonData) {
    if (!jsonData) {
        throw new Error('Invalid marks data format');
    }

    await clearMarks();
    const db = await getDb();

    const tasksData = jsonData.tasks || [];
    const marksData = jsonData.marks || [];
    const membersData = jsonData.members || [];

    // Import tasks with upsert logic (preserve IDs for existing tasks)
    const taskIdMapping = new Map(); // Maps old task IDs to new task IDs

    if (tasksData.length > 0) {
        const tx = db.transaction('tasks', 'readwrite');
        const store = tx.objectStore('tasks');

        for (const task of tasksData) {
            const oldId = task.id;

            // Find existing task by natural key (name + date + groupName)
            const existing = await tasks.findTaskByNaturalKey(task.name, task.date, task.groupName);

            if (existing) {
                // Task exists - preserve its ID and update other fields
                await store.put({ ...task, id: existing.id });
                taskIdMapping.set(oldId, existing.id);
            } else {
                // New task - remove ID to let auto-increment assign one
                const { id, ...taskWithoutId } = task;
                const newId = await store.add(taskWithoutId);
                taskIdMapping.set(oldId, newId);
            }
        }
        await tx.done;
    }

    // Import members
    if (membersData.length > 0) {
        const tx = db.transaction('members', 'readwrite');
        const store = tx.objectStore('members');
        for (const member of membersData) {
            await store.put({ ...member, role: member.role || 'student' });
        }
        await tx.done;
    }

    // Import marks with updated task IDs
    if (marksData.length > 0) {
        const tx = db.transaction('marks', 'readwrite');
        const store = tx.objectStore('marks');
        for (const mark of marksData) {
            // Update taskId to the new ID if mapping exists
            const newTaskId = taskIdMapping.get(mark.taskId) || mark.taskId;
            await store.put({ ...mark, taskId: newTaskId });
        }
        await tx.done;
    }
}
</file>

<file path="db.js">
import { openDB } from 'idb';
import { getCurrentWorkspaceId } from './workspace';

export const DB_VERSION = 9;
export const DEFAULT_DB_NAME = 'meet-attendance-db';

// Dynamic DB Connection Cache
let _dbPromise = null;
let _currentDbName = null;

/**
 * Get database name for current workspace
 */
export function getCurrentDbName() {
    const currentId = getCurrentWorkspaceId();
    const stored = localStorage.getItem('edutrace_workspaces');

    try {
        const workspaces = stored
            ? JSON.parse(stored)
            : [
                {
                    id: 'default',
                    name: 'Default',
                    dbName: DEFAULT_DB_NAME,
                    createdAt: new Date().toISOString(),
                },
            ];

        const workspace = workspaces.find((w) => w.id === currentId);
        return workspace ? workspace.dbName : DEFAULT_DB_NAME;
    } catch (e) {
        // Corrupted JSON or unexpected shape â€“ fall back to default DB
        return DEFAULT_DB_NAME;
    }
}

/**
 * Reset database connection (used when switching workspaces or between tests)
 */
export async function resetDbConnection() {
    if (_dbPromise) {
        try {
            // Await the promise to get the actual DB instance
            const db = await _dbPromise;
            // Explicitly close the connection to release the lock
            db.close();
        } catch (e) {
            console.warn('Error closing DB connection during reset:', e);
        }
    }

    _dbPromise = null;
    _currentDbName = null;
}
/**
 * Initialize database schema and run migrations
 * Shared upgrade logic used by both main DB connection and workspace operations
 * @param {IDBDatabase} db - IndexedDB database instance
 * @param {number} oldVersion - Previous schema version
 * @param {number} newVersion - Target schema version
 * @param {IDBTransaction} transaction - Upgrade transaction
 */
export async function initDbSchema(db, oldVersion, newVersion, transaction) {
    // Store for meets
    if (!db.objectStoreNames.contains('meets')) {
        const meetStore = db.createObjectStore('meets', { keyPath: 'id' });
        meetStore.createIndex('meetId', 'meetId', { unique: false });
        meetStore.createIndex('date', 'date', { unique: false });
    }

    // Store for settings
    if (!db.objectStoreNames.contains('settings')) {
        db.createObjectStore('settings', { keyPath: 'key' });
    }

    // Store for groups
    if (!db.objectStoreNames.contains('groups')) {
        const store = db.createObjectStore('groups', { keyPath: 'id' });
        store.createIndex('meetId', 'meetId', { unique: true }); // Unique by default for new DBs
        store.createIndex('name', 'name', { unique: true });
    } else {
        const store = transaction.objectStore('groups');

        // Ensure meetId is unique (recreate if needed)
        if (store.indexNames.contains('meetId')) {
            if (oldVersion < 7) {
                store.deleteIndex('meetId');
                store.createIndex('meetId', 'meetId', { unique: true });
            }
        } else {
            store.createIndex('meetId', 'meetId', { unique: true });
        }

        // Ensure name index exists and is unique
        if (!store.indexNames.contains('name')) {
            store.createIndex('name', 'name', { unique: true });
        }

        // Migration: Backfill course for groups (v8)
        if (oldVersion < 8) {
            let cursor = await store.openCursor();
            while (cursor) {
                const group = cursor.value;
                let updated = false;

                if (!group.course && group.name) {
                    // Try to extract course from name (e.g. KH-41 -> 4)
                    const match = group.name.match(/\d/);
                    if (match) {
                        const course = parseInt(match[0], 10);
                        if (course >= 1 && course <= 4) {
                            group.course = course;
                            updated = true;
                        }
                    }
                }

                if (updated) {
                    // Ensure we wait for the write inside upgrade
                    await cursor.update(group);
                }

                cursor = await cursor.continue();
            }
        }
    }

    // Store for tasks
    if (!db.objectStoreNames.contains('tasks')) {
        const store = db.createObjectStore('tasks', {
            keyPath: 'id',
            autoIncrement: true,
        });
        store.createIndex('groupId', 'groupId', { unique: false });
        // Natural key: (name, date, groupName)
        store.createIndex('name_date_group', ['name', 'date', 'groupName'], {
            unique: true,
        });
        // Added in v6
        store.createIndex('groupName', 'groupName', { unique: false });
    } else {
        const store = transaction.objectStore('tasks');

        if (!store.indexNames.contains('groupName')) {
            store.createIndex('groupName', 'groupName', { unique: false });
        }

        // Ensure composite index uses (name, date, groupName) as natural key
        if (store.indexNames.contains('name_date_group')) {
            if (oldVersion < 9) {
                store.deleteIndex('name_date_group');
                store.createIndex('name_date_group', ['name', 'date', 'groupName'], {
                    unique: true,
                });
            }
        } else {
            store.createIndex('name_date_group', ['name', 'date', 'groupName'], {
                unique: true,
            });
        }
    }

    // Store for marks
    if (!db.objectStoreNames.contains('marks')) {
        const store = db.createObjectStore('marks', {
            keyPath: 'id',
            autoIncrement: true,
        });
        store.createIndex('taskId', 'taskId', { unique: false });
        store.createIndex('studentId', 'studentId', { unique: false });
        store.createIndex('task_student', ['taskId', 'studentId'], {
            unique: true,
        });
        store.createIndex('createdAt', 'createdAt', { unique: false });
    } else {
        const store = transaction.objectStore('marks');
        if (!store.indexNames.contains('createdAt')) {
            store.createIndex('createdAt', 'createdAt', { unique: false });
        }
    }

    // Store for members (formerly students)
    if (!db.objectStoreNames.contains('members')) {
        const store = db.createObjectStore('members', {
            keyPath: 'id',
            autoIncrement: true,
        });
        store.createIndex('name', 'name', { unique: true }); // Name should be unique for merging
        store.createIndex('groupName', 'groupName', { unique: false });
        store.createIndex('role', 'role', { unique: false });
    }

    // Drop legacy 'students' store from early development versions
    if (oldVersion < 9 && db.objectStoreNames.contains('students')) {
        db.deleteObjectStore('students');
    }
}

/**
 * Internal helper to (re)create DB connection for current workspace
 * @returns {Promise<IDBPDatabase>}
 */
function createDb() {
    const dbName = getCurrentDbName();
    _currentDbName = dbName;

    _dbPromise = openDB(dbName, DB_VERSION, {
        upgrade: initDbSchema,
    });

    return _dbPromise;
}

/**
 * Get IndexedDB connection for current workspace
 * Always use this from repositories instead of importing a raw promise.
 * @returns {Promise<IDBPDatabase>}
 */
export function getDb() {
    const dbName = getCurrentDbName();

    if (_dbPromise && _currentDbName === dbName) {
        return _dbPromise;
    }

    return createDb();
}
</file>

<file path="groups.js">
import { getDb } from './db';
import { getMeetsByMeetId } from './meets';
import { syncParticipants } from './members';

export async function getGroups() {
    const db = await getDb();
    return db.getAll('groups');
}

export async function getGroupById(id) {
    const db = await getDb();
    return db.get('groups', id);
}

export async function saveGroup(group) {
    const db = await getDb();
    await db.put('groups', group);

    // Sync members from existing meets for this group
    if (group.meetId) {
        await syncMembersFromMeets(group);
    }
    return group.id;
}

export async function deleteGroup(id) {
    const db = await getDb();
    return db.delete('groups', id);
}

export async function getGroupMap() {
    const groups = await getGroups();
    const map = {};
    groups.forEach(g => {
        map[g.meetId] = g;
    });
    return map;
}

export async function syncMembersFromMeets(group) {
    const meets = await getMeetsByMeetId(group.meetId);
    await syncParticipants(meets, group.name);
}
</file>

<file path="index.js">
import { getDb } from './db';
import * as workspace from './workspace';
import * as settings from './settings';
import * as meets from './meets';
import * as groups from './groups';
import * as members from './members';
import * as tasks from './tasks';
import * as marks from './marks';
import * as backup from './backup';
import * as stats from './stats';

export const repository = Object.freeze({
    async saveMeet(meetData) {
        return meets.saveMeet(meetData);
    },

    async getAll(storeName) {
        const db = await getDb();
        return db.getAll(storeName);
    },

    async getAllMeets() {
        return meets.getAllMeets();
    },

    async getMeetsByMeetId(meetId) {
        return meets.getMeetsByMeetId(meetId);
    },

    async getMeetById(id) {
        return meets.getMeetById(id);
    },

    async checkMeetExists(meetId, date) {
        return meets.checkMeetExists(meetId, date);
    },

    async isDuplicateFile(filename, meetId, date) {
        return meets.isDuplicateFile(filename, meetId, date);
    },

    async deleteMeet(id) {
        return meets.deleteMeet(id);
    },

    async deleteMeets(ids) {
        return meets.deleteMeets(ids);
    },

    // Groups
    async getGroups() {
        return groups.getGroups();
    },

    async saveGroup(group) {
        return groups.saveGroup(group);
    },

    async syncMembersFromMeets(group) {
        return groups.syncMembersFromMeets(group);
    },

    async syncAllMembersFromMeets() {
        return members.syncAllMembersFromMeets();
    },



    async hideMember(id) {
        return members.hideMember(id);
    },

    async hideMembers(ids) {
        return members.hideMembers(ids);
    },



    async deleteGroup(id) {
        return groups.deleteGroup(id);
    },

    async getGroupMap() {
        return groups.getGroupMap();
    },

    async applyDurationLimitToAll(limitMinutes) {
        return meets.applyDurationLimitToAll(limitMinutes);
    },



    async exportData() {
        return backup.exportData();
    },

    async importData(jsonData) {
        return backup.importData(jsonData);
    },

    async clearAll() {
        return backup.clearAll();
    },

    // Granular Export Methods
    async exportReports() {
        return backup.exportReports();
    },

    async exportGroups() {
        return backup.exportGroups();
    },

    async exportMarks() {
        return backup.exportMarks();
    },

    // Granular Import Methods
    async importReports(jsonData) {
        return backup.importReports(jsonData);
    },

    async importGroups(jsonData) {
        return backup.importGroups(jsonData);
    },

    async importMarks(jsonData) {
        return backup.importMarks(jsonData);
    },

    // Granular Clear Methods
    async clearReports() {
        return backup.clearReports();
    },

    async clearGroups() {
        return backup.clearGroups();
    },

    async clearMarks() {
        return backup.clearMarks();
    },

    async clearMembers() {
        return backup.clearMembers();
    },

    // Legacy alias
    /** @deprecated Use clearMembers instead */
    async clearStudents() {
        return this.clearMembers();
    },

    // Tasks
    async saveTask(task) {
        return tasks.saveTask(task);
    },

    async getAllTasks() {
        return tasks.getAllTasks();
    },

    async getTasksByGroup(groupName) {
        return tasks.getTasksByGroup(groupName);
    },

    async findTaskByNaturalKey(name, date, groupName) {
        return tasks.findTaskByNaturalKey(name, date, groupName);
    },

    // Members (Unified Entity)
    async saveMember(member) {
        return members.saveMember(member);
    },

    async getAllMembers() {
        return members.getAllMembers();
    },

    async getMembersByGroup(groupName) {
        return members.getMembersByGroup(groupName);
    },

    async deleteMember(id) {
        return members.deleteMember(id);
    },

    async deleteMembers(ids) {
        return members.deleteMembers(ids);
    },

    // Legacy Aliases for Students
    /** @deprecated Use saveMember instead */
    async saveStudent(student) {
        return this.saveMember(student);
    },

    /** @deprecated Use getAllMembers instead */
    async getAllStudents() {
        return this.getAllMembers();
    },

    // Workspaces
    getWorkspaces() {
        return workspace.getWorkspaces();
    },

    getCurrentWorkspaceId() {
        return workspace.getCurrentWorkspaceId();
    },

    async createWorkspace(name, options = {}) {
        // Provide callbacks for settings management
        const settingsOptions = {
            ...options,
            getSettings: options.exportSettings ? async () => {
                return {
                    durationLimit: await settings.getDurationLimit(),
                    defaultTeacher: await settings.getDefaultTeacher(),
                    ignoredUsers: await settings.getIgnoredUsers()
                };
            } : null,
            saveSettings: options.exportSettings ? async (s) => {
                await settings.saveDurationLimit(s.durationLimit);
                await settings.saveDefaultTeacher(s.defaultTeacher);
                await settings.saveIgnoredUsers(s.ignoredUsers);
            } : null
        };
        return workspace.createWorkspace(name, settingsOptions);
    },

    async updateWorkspace(id, updates) {
        return workspace.updateWorkspace(id, updates);
    },

    async exportWorkspaces(workspaceIds) {
        return workspace.exportWorkspaces(workspaceIds);
    },

    async importWorkspaces(data, selectedIds) {
        return workspace.importWorkspaces(data, selectedIds);
    },

    // Settings
    async getDurationLimit() {
        return settings.getDurationLimit();
    },

    async saveDurationLimit(limit) {
        return settings.saveDurationLimit(limit);
    },

    async getDefaultTeacher() {
        return settings.getDefaultTeacher();
    },

    async saveDefaultTeacher(teacher) {
        return settings.saveDefaultTeacher(teacher);
    },

    async getIgnoredUsers() {
        return settings.getIgnoredUsers();
    },

    async saveIgnoredUsers(users) {
        return settings.saveIgnoredUsers(users);
    },

    async switchWorkspace(id) {
        return workspace.switchWorkspace(id);
    },

    async deleteWorkspace(id) {
        return workspace.deleteWorkspace(id);
    },

    async deleteWorkspacesData(workspaceIds) {
        return workspace.deleteWorkspacesData(workspaceIds);
    },



    async getStudentsByGroup(groupName) {
        return this.getMembersByGroup(groupName);
    },

    // Teachers (Settings)
    async getTeachers() {
        return settings.getTeachers();
    },

    async saveTeachers(teachers) {
        return settings.saveTeachers(teachers);
    },

    // Marks
    async saveMark(mark) {
        return marks.saveMark(mark);
    },

    async getMarksByTask(taskId) {
        return marks.getMarksByTask(taskId);
    },

    async updateMarkSynced(id, synced) {
        return marks.updateMarkSynced(id, synced);
    },

    async getMarksByStudent(studentId) {
        return marks.getMarksByStudent(studentId);
    },

    async deleteMark(id) {
        return marks.deleteMark(id);
    },

    async deleteMarks(ids) {
        return marks.deleteMarks(ids);
    },

    async getAllMarksWithRelations() {
        return marks.getAllMarksWithRelations();
    },

    // Entity Statistics
    async getEntityCounts() {
        return stats.getEntityCounts();
    },

    async getEntitySizes() {
        return stats.getEntitySizes();
    },

    async getAllWorkspacesSizes() {
        return stats.getAllWorkspacesSizes();
    }
});
</file>

<file path="marks.js">
import { getDb } from './db';

export async function getAllMarks() {
    const db = await getDb();
    return db.getAll('marks');
}

export async function saveMark(mark) {
    const db = await getDb();
    const tx = db.transaction('marks', 'readwrite');

    // Check for duplicates using composite index
    const index = tx.store.index('task_student');
    const existing = await index.get([mark.taskId, mark.studentId]);

    if (existing) {
        // Update existing mark if score changed
        if (existing.score !== mark.score) {
            const updated = { ...existing, score: mark.score, synced: false };
            await tx.store.put(updated);
            await tx.done;
            return { id: existing.id, isNew: false };
        }
        // Score is same, so it's a true duplicate/skip
        return { id: existing.id, isNew: false };
    }

    const id = await tx.store.add({
        ...mark,
        createdAt: new Date().toISOString()
    });
    await tx.done;
    return { id, isNew: true };
}

export async function getMarksByTask(taskId) {
    const db = await getDb();
    return db.getAllFromIndex('marks', 'taskId', taskId);
}

export async function updateMarkSynced(id, synced) {
    const db = await getDb();
    const tx = db.transaction('marks', 'readwrite');
    const mark = await tx.store.get(id);
    if (mark) {
        mark.synced = synced;
        await tx.store.put(mark);
    }
    await tx.done;
}

export async function getMarksByStudent(studentId) {
    const db = await getDb();
    return db.getAllFromIndex('marks', 'studentId', studentId);
}

export async function deleteMark(id) {
    const db = await getDb();
    return db.delete('marks', id);
}

export async function deleteMarks(ids) {
    const db = await getDb();
    const tx = db.transaction('marks', 'readwrite');
    const store = tx.objectStore('marks');
    await Promise.all(ids.map(id => store.delete(id)));
    await tx.done;
}

export async function getAllMarksWithRelations() {
    const db = await getDb();

    // Fetch all data in parallel - single batch operation
    const [allMarks, allTasks, allMembers] = await Promise.all([
        db.getAll('marks'),
        db.getAll('tasks'),
        db.getAll('members')
    ]);

    // Build lookup maps for O(1) access
    const taskMap = new Map(allTasks.map(t => [t.id, t]));
    const memberMap = new Map(allMembers.map(m => [m.id, m]));

    // Transform marks with related data in a single pass
    const flatMarks = [];
    for (const mark of allMarks) {
        const task = taskMap.get(mark.taskId);
        const student = memberMap.get(mark.studentId);

        // Skip if related data is missing (orphaned records)
        if (!task || !student) continue;

        flatMarks.push({
            id: mark.id,
            studentName: student.name,
            groupName: task.groupName,
            taskName: task.name,
            taskDate: task.date,
            maxPoints: task.maxPoints,
            score: mark.score,
            synced: mark.synced,
            createdAt: mark.createdAt
        });
    }

    return flatMarks;
}
</file>

<file path="meets.js">
import { getDb } from './db';

export async function saveMeet(meetData) {
    const db = await getDb();
    return db.put('meets', meetData);
}

export async function getAllMeets() {
    const db = await getDb();
    return db.getAll('meets');
}

export async function getMeetsByMeetId(meetId) {
    const db = await getDb();
    return db.getAllFromIndex('meets', 'meetId', meetId);
}

export async function getMeetById(id) {
    const db = await getDb();
    return db.get('meets', id);
}

export async function checkMeetExists(meetId, date) {
    const db = await getDb();
    const meets = await db.getAllFromIndex('meets', 'meetId', meetId);
    return meets.some(m => m.date === date);
}

export async function isDuplicateFile(filename, meetId, date) {
    const db = await getDb();
    const meets = await db.getAllFromIndex('meets', 'meetId', meetId);
    return meets.some(m => m.date === date && m.filename === filename);
}

export async function deleteMeet(id) {
    const db = await getDb();
    return db.delete('meets', id);
}

export async function deleteMeets(ids) {
    const db = await getDb();
    const tx = db.transaction('meets', 'readwrite');
    const store = tx.objectStore('meets');
    await Promise.all(ids.map(id => store.delete(id)));
    await tx.done;
}

export async function applyDurationLimitToAll(limitMinutes) {
    if (!limitMinutes || limitMinutes <= 0) return 0;

    const limitSeconds = limitMinutes * 60;
    const db = await getDb();
    const meets = await db.getAll('meets');
    let fixedCount = 0;

    const tx = db.transaction('meets', 'readwrite');
    const store = tx.objectStore('meets');

    for (const meet of meets) {
        let changed = false;
        if (meet.participants) {
            meet.participants.forEach(p => {
                if (p.duration > limitSeconds) {
                    p.duration = limitSeconds;
                    changed = true;
                }
            });
        }

        if (changed) {
            await store.put(meet);
            fixedCount++;
        }
    }

    await tx.done;
    return fixedCount;
}
</file>

<file path="members.js">
import { getDb } from './db';
import { getTeachers } from './settings';
import { getAllMeets } from './meets';
import { getGroupMap } from './groups';

export async function getAllMembers() {
    const db = await getDb();
    return db.getAll('members');
}

async function buildMemberNameMap() {
    const allMembers = await getAllMembers();
    const memberMap = new Map();
    allMembers.forEach(m => {
        memberMap.set(m.name, m);
        if (m.aliases) {
            m.aliases.forEach(a => memberMap.set(a, m));
        }
    });
    return memberMap;
}

export async function syncAllMembersFromMeets() {
    const meets = await getAllMeets();
    const groupMap = await getGroupMap();

    const memberMap = await buildMemberNameMap();

    const db = await getDb();
    const tx = db.transaction('members', 'readwrite');
    const store = tx.objectStore('members');

    for (const meet of meets) {
        const group = groupMap[meet.meetId];
        const groupName = group ? group.name : '';

        for (const p of meet.participants) {
            if (!memberMap.has(p.name)) {
                const newMember = {
                    name: p.name,
                    groupName: groupName,
                    email: p.email || '',
                    role: 'student',
                    aliases: [],
                    hidden: false
                };
                const id = await store.add(newMember);
                newMember.id = id;
                memberMap.set(p.name, newMember);
            }
        }
    }
    await tx.done;
}

export async function getMembersByGroup(groupName) {
    const db = await getDb();
    return db.getAllFromIndex('members', 'groupName', groupName);
}

export async function getMemberById(id) {
    const db = await getDb();
    return db.get('members', id);
}

export async function saveMember(member) {
    // Resolve role before transaction
    let role = member.role;
    if (!role) {
        const teachers = await getTeachers();
        role = teachers.includes(member.name) ? 'teacher' : 'student';
    }

    const db = await getDb();
    const tx = db.transaction('members', 'readwrite');
    const store = tx.objectStore('members');

    let existing;
    if (member.id) {
        existing = await store.get(member.id);
    }

    if (!existing && member.name) {
        const index = store.index('name');
        existing = await index.get(member.name);
    }

    if (existing) {
        // Merge
        const updated = {
            aliases: [], // Default
            ...existing,
            ...member,
            id: existing.id,
            role: role
        };
        await store.put(updated);
        await tx.done;
        return existing.id;
    }

    const newMember = { aliases: [], ...member, role };
    const id = await store.add(newMember);
    await tx.done;
    return id;
}

export async function deleteMember(id) {
    const db = await getDb();
    return db.delete('members', id);
}

export async function deleteMembers(ids) {
    const db = await getDb();
    const tx = db.transaction('members', 'readwrite');
    const store = tx.objectStore('members');
    await Promise.all(ids.map(id => store.delete(id)));
    await tx.done;
}

export async function hideMember(id) {
    const db = await getDb();
    const tx = db.transaction('members', 'readwrite');
    const store = tx.objectStore('members');
    const member = await store.get(id);
    if (member) {
        member.hidden = true;
        await store.put(member);
    }
    await tx.done;
}

export async function hideMembers(ids) {
    const db = await getDb();
    const tx = db.transaction('members', 'readwrite');
    const store = tx.objectStore('members');
    await Promise.all(ids.map(async id => {
        const member = await store.get(id);
        if (member) {
            member.hidden = true;
            await store.put(member);
        }
    }));
    await tx.done;
}

export async function syncParticipants(meets, groupName) {
    const memberMap = await buildMemberNameMap();

    const db = await getDb();
    const tx = db.transaction('members', 'readwrite');
    const store = tx.objectStore('members');

    for (const meet of meets) {
        for (const p of meet.participants) {
            if (!memberMap.has(p.name)) {
                const newMember = {
                    name: p.name,
                    groupName: groupName,
                    email: p.email || '',
                    role: 'student',
                    aliases: [],
                    hidden: false
                };
                const id = await store.add(newMember);
                newMember.id = id;
                memberMap.set(p.name, newMember);
            }
        }
    }
    await tx.done;
}
</file>

<file path="settings.js">
import { getCurrentWorkspaceId } from './workspace';
import { getDb } from './db';

// Duration Limit
export async function getDurationLimit() {
    try {
        const wsId = getCurrentWorkspaceId();
        const key = wsId === 'default' ? 'durationLimit' : `durationLimit_${wsId}`;
        const stored = localStorage.getItem(key);
        if (!stored) return 0;
        const parsed = parseInt(stored, 10);
        return isNaN(parsed) ? 0 : parsed;
    } catch (e) {
        console.error('Error reading duration limit from localStorage', e);
        return 0;
    }
}

export async function saveDurationLimit(limit) {
    const wsId = getCurrentWorkspaceId();
    const key = wsId === 'default' ? 'durationLimit' : `durationLimit_${wsId}`;
    localStorage.setItem(key, limit);
}

// Default Teacher
export async function getDefaultTeacher() {
    try {
        const wsId = getCurrentWorkspaceId();
        const key = wsId === 'default' ? 'defaultTeacher' : `defaultTeacher_${wsId}`;
        const stored = localStorage.getItem(key);
        return stored ? JSON.parse(stored) : null;
    } catch (e) {
        console.error('Error reading default teacher from localStorage', e);
        return null;
    }
}

export async function saveDefaultTeacher(teacher) {
    const wsId = getCurrentWorkspaceId();
    const key = wsId === 'default' ? 'defaultTeacher' : `defaultTeacher_${wsId}`;
    localStorage.setItem(key, JSON.stringify(teacher));
}

// Ignored Users
export async function getIgnoredUsers() {
    try {
        const wsId = getCurrentWorkspaceId();
        const key = wsId === 'default' ? 'ignoredUsers' : `ignoredUsers_${wsId}`;
        const stored = localStorage.getItem(key);
        return stored ? JSON.parse(stored) : [];
    } catch (e) {
        console.error('Error reading ignored users from localStorage', e);
        return [];
    }
}

export async function saveIgnoredUsers(users) {
    const wsId = getCurrentWorkspaceId();
    const key = wsId === 'default' ? 'ignoredUsers' : `ignoredUsers_${wsId}`;
    localStorage.setItem(key, JSON.stringify(users));
}

// Teachers
export async function getTeachers() {
    try {
        const wsId = getCurrentWorkspaceId();
        const key = wsId === 'default' ? 'teachers' : `teachers_${wsId}`;
        const stored = localStorage.getItem(key);
        return stored ? JSON.parse(stored) : [];
    } catch (e) {
        console.error('Error reading teachers from localStorage', e);
        return [];
    }
}

export async function saveTeachers(teachers) {
    try {
        const wsId = getCurrentWorkspaceId();
        const key = wsId === 'default' ? 'teachers' : `teachers_${wsId}`;
        localStorage.setItem(key, JSON.stringify(teachers));

        // Sync roles in DB
        const db = await getDb();
        const tx = db.transaction('members', 'readwrite');
        const allMembers = await tx.store.getAll();

        const teacherSet = new Set(teachers);

        for (const member of allMembers) {
            const isTeacher = teacherSet.has(member.name);
            const currentRole = member.role || 'student';

            if (isTeacher && currentRole !== 'teacher') {
                member.role = 'teacher';
                await tx.store.put(member);
            } else if (!isTeacher && currentRole === 'teacher') {
                member.role = 'student';
                await tx.store.put(member);
            }
        }
        await tx.done;
    } catch (e) {
        console.error('Error saving teachers to localStorage', e);
    }
}

export function clearSettings() {
    const wsId = getCurrentWorkspaceId();
    const keySuffix = wsId === 'default' ? '' : `_${wsId}`;

    localStorage.removeItem(wsId === 'default' ? 'ignoredUsers' : `ignoredUsers${keySuffix}`);
    localStorage.removeItem(wsId === 'default' ? 'durationLimit' : `durationLimit${keySuffix}`);
    localStorage.removeItem(wsId === 'default' ? 'defaultTeacher' : `defaultTeacher${keySuffix}`);
    localStorage.removeItem(wsId === 'default' ? 'teachers' : `teachers${keySuffix}`);
}
</file>

<file path="stats.js">
import { getDb } from './db';
import * as workspace from './workspace';
import * as meets from './meets';
import * as marks from './marks';
import * as groups from './groups';
import * as tasks from './tasks';
import * as members from './members';

export async function getEntityCounts() {
    const db = await getDb();
    const [meetsCount, groupsCount, tasksCount, marksCount, membersCount] = await Promise.all([
        db.count('meets'),
        db.count('groups'),
        db.count('tasks'),
        db.count('marks'),
        db.count('members')
    ]);

    return {
        reports: meetsCount,
        groups: groupsCount,
        marks: marksCount,
        tasks: tasksCount,
        members: membersCount
    };
}

export async function getEntitySizes() {
    const [allMeets, allGroups, allTasks, allMarks, allMembers] = await Promise.all([
        meets.getAllMeets(),
        groups.getGroups(),
        tasks.getAllTasks(),
        marks.getAllMarks(),
        members.getAllMembers()
    ]);

    // Estimate size in bytes using JSON.stringify
    const getSize = (data) => {
        try {
            return new Blob([JSON.stringify(data)]).size;
        } catch (e) {
            return 0;
        }
    };

    return {
        reports: getSize(allMeets),
        groups: getSize(allGroups),
        marks: getSize(allMarks) + getSize(allTasks), // Marks includes tasks
        tasks: getSize(allTasks),
        members: getSize(allMembers)
    };
}

export async function getAllWorkspacesSizes() {
    return workspace.getAllWorkspacesSizes();
}
</file>

<file path="tasks.js">
import { getDb } from './db';

export async function saveTask(task) {
    const db = await getDb();
    const tx = db.transaction('tasks', 'readwrite');

    // Use composite natural key (name, date, groupName) to detect duplicates
    const index = tx.store.index('name_date_group');
    const existing = await index.get([task.name, task.date, task.groupName]);

    if (existing) {
        return { id: existing.id, isNew: false };
    }

    const id = await tx.store.add(task);
    await tx.done;
    return { id, isNew: true };
}

export async function getAllTasks() {
    const db = await getDb();
    return db.getAll('tasks');
}

export async function getTasksByGroup(groupName) {
    const db = await getDb();
    return db.getAllFromIndex('tasks', 'groupName', groupName);
}

export async function findTaskByNaturalKey(name, date, groupName) {
    const db = await getDb();
    return db.getFromIndex('tasks', 'name_date_group', [name, date, groupName]);
}

export async function getTaskById(id) {
    const db = await getDb();
    return db.get('tasks', id);
}
</file>

<file path="types.js">
/**
 * @typedef {Object} Meet
 * @property {string} id
 * @property {string} meetId
 * @property {string} date
 * @property {string} [filename]
 * @property {Array<{ name: string, email?: string, duration: number }>} participants
 */

/**
 * @typedef {Object} Group
 * @property {string} id
 * @property {string} name
 * @property {string} meetId
 * @property {number} [course]
 */

/**
 * @typedef {Object} Member
 * @property {number} id
 * @property {string} name
 * @property {string} groupName
 * @property {string} role  // 'student' | 'teacher'
 * @property {string[]} [aliases]
 * @property {boolean} [hidden]
 * @property {string} [email]
 */

/**
 * @typedef {Object} Task
 * @property {number} id
 * @property {string} name
 * @property {string} date
 * @property {string} groupName
 * @property {number} [maxPoints]
 * @property {string} [groupId]
 */

/**
 * @typedef {Object} Mark
 * @property {number} id
 * @property {number} taskId
 * @property {number} studentId
 * @property {number} score
 * @property {string} createdAt
 * @property {boolean} [synced]
 */

export { };
</file>

<file path="workspace.js">
import { openDB } from 'idb';
import { DB_VERSION, resetDbConnection, initDbSchema } from './db';

const WORKSPACE_KEY = 'edutrace_workspaces';
const CURRENT_WORKSPACE_KEY = 'edutrace_current_workspace';

/**
 * Get all workspaces from localStorage
 * @returns {Array} Array of workspace objects
 */
export function getWorkspaces() {
    try {
        const stored = localStorage.getItem(WORKSPACE_KEY);
        return stored ? JSON.parse(stored) : [{
            id: 'default',
            name: 'Default',
            dbName: 'meet-attendance-db',
            createdAt: new Date().toISOString()
        }];
    } catch (e) {
        return [{
            id: 'default',
            name: 'Default',
            dbName: 'meet-attendance-db',
            createdAt: new Date().toISOString()
        }];
    }
}

/**
 * Save workspaces list to localStorage
 * @param {Array} workspaces - Array of workspace objects
 */
export function saveWorkspaces(workspaces) {
    localStorage.setItem(WORKSPACE_KEY, JSON.stringify(workspaces));
}

/**
 * Get current workspace ID
 * @returns {string} Current workspace ID
 */
export function getCurrentWorkspaceId() {
    return localStorage.getItem(CURRENT_WORKSPACE_KEY) || 'default';
}

/**
 * Set current workspace ID
 * @param {string} id - Workspace ID
 */
export function setCurrentWorkspaceId(id) {
    localStorage.setItem(CURRENT_WORKSPACE_KEY, id);
}

/**
 * Create a new workspace
 * @param {string} name - Workspace name
 * @param {Object} options - Options object
 * @param {string} options.icon - Icon name
 * @param {boolean} options.exportSettings - Copy settings from current workspace
 * @param {Function} options.getSettings - Function to get current settings
 * @param {Function} options.saveSettings - Function to save settings
 * @returns {Promise<string>} New workspace ID
 */
export async function createWorkspace(name, options = {}) {
    const workspaces = getWorkspaces();
    const id = crypto.randomUUID();
    const newWorkspace = {
        id,
        name,
        icon: options.icon || 'Database',
        dbName: `meet-attendance-db-${id}`,
        createdAt: new Date().toISOString()
    };
    workspaces.push(newWorkspace);
    saveWorkspaces(workspaces);

    if (options.exportSettings && options.getSettings && options.saveSettings) {
        // Get current settings
        const settings = await options.getSettings();

        // Switch to new workspace temporarily
        const originalWorkspaceId = getCurrentWorkspaceId();
        setCurrentWorkspaceId(id);
        await resetDbConnection();

        // Save settings to new workspace
        await options.saveSettings(settings);

        // Restore original workspace
        setCurrentWorkspaceId(originalWorkspaceId);
        await resetDbConnection();
    }

    return id;
}

/**
 * Update workspace metadata
 * @param {string} id - Workspace ID
 * @param {Object} updates - Fields to update
 * @returns {Promise<Object>} Updated workspace
 */
export async function updateWorkspace(id, updates) {
    const workspaces = getWorkspaces();
    const index = workspaces.findIndex(w => w.id === id);

    if (index === -1) {
        throw new Error('Workspace not found');
    }

    // Prevent updating default workspace ID or dbName
    const { id: _, dbName: __, ...allowedUpdates } = updates;

    // Update workspace properties
    workspaces[index] = {
        ...workspaces[index],
        ...allowedUpdates,
        updatedAt: new Date().toISOString()
    };

    saveWorkspaces(workspaces);
    return workspaces[index];
}

/**
 * Switch to a different workspace
 * @param {string} id - Target workspace ID
 * @param {Function} onLoading - Callback function to be called when loading starts
 */
export async function switchWorkspace(id, onLoading = () => { }) {
    const workspaces = getWorkspaces();
    if (!workspaces.find(w => w.id === id)) {
        throw new Error('Workspace not found');
    }
    setCurrentWorkspaceId(id);
    await resetDbConnection();
    onLoading();
}

/**
 * Delete a workspace and its database
 * @param {string} id - Workspace ID
 */
export async function deleteWorkspace(id) {
    if (id === 'default') {
        throw new Error('Cannot delete default workspace');
    }

    const workspaces = getWorkspaces();
    const workspace = workspaces.find(w => w.id === id);
    if (!workspace) return;

    // Delete DB
    await indexedDB.deleteDatabase(workspace.dbName);

    // Update list
    const newWorkspaces = workspaces.filter(w => w.id !== id);
    saveWorkspaces(newWorkspaces);

    // If current was deleted, switch to default
    if (getCurrentWorkspaceId() === id) {
        await switchWorkspace('default');
    }
}

/**
 * Export multiple workspaces to backup file
 * @param {Array<string>} workspaceIds - IDs of workspaces to export
 * @returns {Promise<Object>} Export data
 */
export async function exportWorkspaces(workspaceIds) {
    const allWorkspaces = getWorkspaces();
    const workspacesToExport = allWorkspaces.filter(w => workspaceIds.includes(w.id));

    const exportData = {
        type: 'multi-workspace-backup',
        version: 1,
        timestamp: new Date().toISOString(),
        workspaces: []
    };

    for (const ws of workspacesToExport) {
        const db = await openDB(ws.dbName, DB_VERSION);
        try {
            const [meets, groups, tasks, marks, members] = await Promise.all([
                db.getAll('meets'),
                db.getAll('groups'),
                db.getAll('tasks'),
                db.getAll('marks'),
                db.getAll('members')
            ]);

            exportData.workspaces.push({
                id: ws.id,
                name: ws.name,
                icon: ws.icon,
                dbName: ws.dbName,
                data: { meets, groups, tasks, marks, members }
            });
        } finally {
            db.close();
        }
    }

    return exportData;
}

/**
 * Import workspaces from backup file
 * @param {Object} data - Backup data
 * @param {Array<string>} selectedIds - IDs of workspaces to import
 */
export async function importWorkspaces(data, selectedIds) {
    if (!data.workspaces || !Array.isArray(data.workspaces)) {
        throw new Error('Invalid workspace backup format');
    }

    const workspacesToImport = data.workspaces.filter(w => selectedIds.includes(w.id));
    const currentWorkspaces = getWorkspaces();

    for (const wsData of workspacesToImport) {
        // Check if workspace exists
        let targetWs = currentWorkspaces.find(w => w.id === wsData.id);

        if (!targetWs) {
            // Create new workspace entry
            targetWs = {
                id: wsData.id,
                name: wsData.name,
                icon: wsData.icon || 'Database',
                dbName: wsData.dbName || `meet-attendance-db-${wsData.id}`,
                createdAt: new Date().toISOString()
            };
            currentWorkspaces.push(targetWs);
            saveWorkspaces(currentWorkspaces);
        }

        // Import data into workspace's DB - ensure schema is initialized
        const db = await openDB(targetWs.dbName, DB_VERSION, {
            upgrade: initDbSchema
        });

        try {
            const tx = db.transaction(['meets', 'groups', 'tasks', 'marks', 'members'], 'readwrite');

            // Clear existing data
            await Promise.all([
                tx.objectStore('meets').clear(),
                tx.objectStore('groups').clear(),
                tx.objectStore('tasks').clear(),
                tx.objectStore('marks').clear(),
                tx.objectStore('members').clear()
            ]);

            // Import new data
            const { meets, groups, tasks, marks, members } = wsData.data;

            if (meets) {
                for (const m of meets) {
                    await tx.objectStore('meets').put(m);
                }
            }
            if (groups) {
                for (const g of groups) {
                    await tx.objectStore('groups').put(g);
                }
            }
            if (tasks) {
                for (const t of tasks) {
                    await tx.objectStore('tasks').put(t);
                }
            }
            if (marks) {
                for (const m of marks) {
                    await tx.objectStore('marks').put(m);
                }
            }
            if (members) {
                for (const m of members) {
                    await tx.objectStore('members').put(m);
                }
            }

            await tx.done;
        } finally {
            db.close();
        }
    }
}

/**
 * Clear data from specific workspaces
 * @param {Array<string>} workspaceIds - IDs of workspaces to clear
 */
export async function deleteWorkspacesData(workspaceIds) {
    const workspaces = getWorkspaces();

    for (const id of workspaceIds) {
        const workspace = workspaces.find(w => w.id === id);
        if (!workspace) continue;

        // Open the workspace database
        const db = await openDB(workspace.dbName, DB_VERSION, {
            upgrade: initDbSchema
        });

        try {
            // Clear all data from the workspace
            const tx = db.transaction(['meets', 'groups', 'tasks', 'marks', 'members'], 'readwrite');

            await Promise.all([
                tx.objectStore('meets').clear(),
                tx.objectStore('groups').clear(),
                tx.objectStore('tasks').clear(),
                tx.objectStore('marks').clear(),
                tx.objectStore('members').clear()
            ]);

            await tx.done;
        } finally {
            db.close();
        }
    }
}

/**
 * Calculate storage size for all workspaces
 * @returns {Promise<Object>} Size information
 */
export async function getAllWorkspacesSizes() {
    const workspaces = getWorkspaces();
    const results = [];
    let total = 0;

    for (const ws of workspaces) {
        const db = await openDB(ws.dbName, DB_VERSION, {
            upgrade: initDbSchema
        });

        try {
            // Check if all required stores exist
            const storeNames = ['meets', 'groups', 'tasks', 'marks', 'members'];
            const missingStores = storeNames.filter(name => !db.objectStoreNames.contains(name));

            if (missingStores.length > 0) {
                console.warn(`Workspace ${ws.name} is missing stores: ${missingStores.join(', ')}. Skipping size calculation.`);
                db.close();
                results.push({
                    id: ws.id,
                    name: ws.name,
                    size: 0,
                    error: true
                });
                continue;
            }

            const [meets, groups, tasks, marks, members] = await Promise.all([
                db.getAll('meets'),
                db.getAll('groups'),
                db.getAll('tasks'),
                db.getAll('marks'),
                db.getAll('members')
            ]);

            const getSize = (data) => {
                try {
                    return new Blob([JSON.stringify(data)]).size;
                } catch (e) {
                    return 0;
                }
            };

            const size = getSize(meets) + getSize(groups) + getSize(tasks) + getSize(marks) + getSize(members);
            total += size;
            results.push({
                id: ws.id,
                name: ws.name,
                size: size
            });
        } catch (e) {
            console.error(`Error calculating size for workspace ${ws.name}:`, e);
            results.push({
                id: ws.id,
                name: ws.name,
                size: 0,
                error: true
            });
        } finally {
            db.close();
        }
    }

    return {
        total,
        workspaces: results
    };
}
</file>

</files>
